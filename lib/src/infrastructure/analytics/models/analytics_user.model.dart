/// Model representing a user for analytics purposes.
///
/// This model is used to identify users and attach user properties
/// to analytics events.
///
/// ## Usage Example
///
/// ```dart
/// // Basic user identification
/// final user = AnalyticsUser(
///   id: 'user_123',
///   email: 'john@example.com',
/// );
///
/// // User with full details
/// final detailedUser = AnalyticsUser(
///   id: 'user_123',
///   email: 'john@example.com',
///   name: 'John Doe',
///   phone: '+1234567890',
///   properties: {
///     'plan': 'premium',
///     'signup_date': '2025-01-01',
///     'country': 'US',
///     'age': 30,
///     'preferences': {
///       'notifications': true,
///       'theme': 'dark',
///     },
///   },
/// );
///
/// // Identify user in analytics
/// await analytics.identifyUser(user);
/// ```
class AnalyticsUser {
  /// Unique identifier for the user.
  ///
  /// This should be a stable identifier that persists across sessions.
  /// Examples: database ID, UUID, email (if stable)
  final String id;

  /// User's email address.
  final String? email;

  /// User's name.
  final String? name;

  /// User's phone number.
  final String? phone;

  /// Additional custom properties about the user.
  ///
  /// Can contain any JSON-serializable data that helps you understand
  /// user behavior and segment your analytics.
  ///
  /// Common properties:
  /// - plan: subscription tier (free, premium, enterprise)
  /// - signup_date: when user joined
  /// - country: user's country
  /// - language: preferred language
  /// - age: user's age
  /// - gender: user's gender
  /// - lifetime_value: total value generated by user
  final Map<String, dynamic>? properties;

  const AnalyticsUser({
    required this.id,
    this.email,
    this.name,
    this.phone,
    this.properties,
  });

  /// Creates a copy of this user with optional field updates.
  AnalyticsUser copyWith({
    String? id,
    String? email,
    String? name,
    String? phone,
    Map<String, dynamic>? properties,
  }) {
    return AnalyticsUser(
      id: id ?? this.id,
      email: email ?? this.email,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      properties: properties ?? this.properties,
    );
  }

  /// Converts this user to a map.
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      if (email != null) 'email': email,
      if (name != null) 'name': name,
      if (phone != null) 'phone': phone,
      if (properties != null) 'properties': properties,
    };
  }

  /// Creates a user from a map.
  factory AnalyticsUser.fromMap(Map<String, dynamic> map) {
    return AnalyticsUser(
      id: map['id'] as String,
      email: map['email'] as String?,
      name: map['name'] as String?,
      phone: map['phone'] as String?,
      properties: map['properties'] as Map<String, dynamic>?,
    );
  }

  /// Returns all user properties including standard fields.
  ///
  /// This combines the standard fields (email, name, phone) with
  /// custom properties into a single map.
  Map<String, dynamic> getAllProperties() {
    final allProps = <String, dynamic>{
      'id': id,
    };

    if (email != null) allProps['email'] = email;
    if (name != null) allProps['name'] = name;
    if (phone != null) allProps['phone'] = phone;

    if (properties != null) {
      allProps.addAll(properties!);
    }

    return allProps;
  }

  @override
  String toString() {
    return 'AnalyticsUser(id: $id, email: $email, name: $name, phone: $phone, properties: $properties)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is AnalyticsUser &&
        other.id == id &&
        other.email == email &&
        other.name == name &&
        other.phone == phone &&
        _mapsEqual(other.properties, properties);
  }

  @override
  int get hashCode {
    return id.hashCode ^
        email.hashCode ^
        name.hashCode ^
        phone.hashCode ^
        properties.hashCode;
  }

  /// Helper method to compare maps for equality.
  bool _mapsEqual(Map<String, dynamic>? a, Map<String, dynamic>? b) {
    if (a == null && b == null) return true;
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;

    for (final key in a.keys) {
      if (!b.containsKey(key) || a[key] != b[key]) {
        return false;
      }
    }

    return true;
  }
}
