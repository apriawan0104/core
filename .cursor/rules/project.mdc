---
alwaysApply: false
---

# BUMA Core - Project Guidelines

## ğŸ¯ Project Overview

**BUMA Core** adalah Flutter core library yang dapat dipakai di semua aplikasi mobile Flutter. Library ini menyediakan business logic, infrastructure services, dan utilities yang reusable dan generic.

**Tujuan**: Membuat core library yang:
- âœ… Generic dan reusable untuk semua Flutter apps
- âœ… Tidak perlu diubah untuk setiap app
- âœ… Mudah di-maintain dan di-test
- âœ… Mengikuti Clean Architecture principles

---

## ğŸ—ï¸ Architecture Principles

### 1. Dependency Inversion Principle (DIP)

**Wajib membungkus (wrap) semua package pihak ketiga dengan abstract class (interface).**

```dart
// âœ… GOOD: Wrap third-party package dengan interface
abstract class StorageService {
  Future<void> save<T>(String key, T value);
  Future<T?> get<T>(String key);
}

class HiveStorageServiceImpl implements StorageService {
  // Implementation menggunakan Hive package
}

// âŒ BAD: Langsung expose third-party package
class StorageService {
  final HiveBox box; // Direct dependency ke Hive
}
```

**Kenapa penting?**
- Consumer app tidak terikat ke package tertentu
- Mudah switch implementation tanpa ubah consumer code
- Testable dengan mock implementations
- Breaking changes di package tidak affect consumer

### 2. Core Library Tetap Generic

**Core library TIDAK boleh contain logic spesifik untuk satu app.**

```dart
// âœ… GOOD: Generic notification service
abstract class NotificationService {
  Future<void> showNotification(String title, String body);
  Stream<NotificationData> get onNotificationTapped;
}

// âŒ BAD: App-specific logic di core
abstract class NotificationService {
  Future<void> showAbsensiReminder(); // Spesifik untuk satu app
  Future<void> showPayslipNotification(); // Spesifik untuk satu app
}
```

**Guidelines:**
- Gunakan generic interfaces dan contracts
- Business logic spesifik app ada di consumer app
- Core hanya provide building blocks

### 3. Backward Compatible - Hooks Optional

**Semua hooks/callbacks harus optional. App yang tidak butuh bisa skip.**

```dart
// âœ… GOOD: Optional hooks
abstract class NotificationService {
  Future<void> initialize({
    OnNotificationTappedCallback? onTapped,
    OnForegroundNotificationCallback? onForeground,
  });
}

// âŒ BAD: Required hooks
abstract class NotificationService {
  // Memaksa semua app implement callback
  Future<void> initialize(OnNotificationTappedCallback onTapped);
}
```

**Benefits:**
- App lama tetap jalan tanpa update
- App baru bisa manfaatkan features baru
- Gradual migration path

### 4. Flexible - Setiap App Inject Logic Berbeda

**Gunakan strategy pattern dan dependency injection untuk flexibility.**

```dart
// Core library provide interface
abstract class NotificationHandler {
  Future<void> handleNotification(NotificationData data);
}

// Consumer app inject custom implementation
class MyAppNotificationHandler implements NotificationHandler {
  @override
  Future<void> handleNotification(NotificationData data) {
    // Custom logic per app
    if (data.type == 'absensi') {
      // Navigate to absensi page
    }
  }
}

// Register di DI
GetIt.instance.registerSingleton<NotificationHandler>(
  MyAppNotificationHandler()
);
```

### 5. Clean - Separation of Concerns

**Follow layered architecture dari ARCHITECTURE.md:**

```
foundation/domain/     â†’ Pure business entities & use cases
foundation/data/       â†’ DTOs for API communication
infrastructure/        â†’ Third-party integrations (wrapped!)
application/           â†’ App-level services
configuration/         â†’ Setup & DI
```

**Dependency Rules:**
- Domain layer: NO external dependencies
- Data layer: Can depend on domain
- Infrastructure: Depends on domain interfaces only
- Application: Orchestrates domain + infrastructure

### 6. Testable

**Semua services harus mudah di-test di consumer app.**

```dart
// Interface di core
abstract class NetworkService {
  Future<Response> get(String url);
}

// Consumer app bisa easily mock
class MockNetworkService implements NetworkService {
  @override
  Future<Response> get(String url) async {
    return Response(data: {'test': 'data'});
  }
}

// Test di consumer app
test('should fetch user data', () {
  final mockNetwork = MockNetworkService();
  final repository = UserRepository(mockNetwork);
  // Test without real network calls
});
```

**Guidelines:**
- All dependencies injected via constructor
- Use interfaces, not concrete classes
- No static methods for stateful operations
- No singletons (except DI container)

---

## ğŸ“‚ Architecture Structure

Ikuti struktur dari `ARCHITECTURE.md`:

```
lib/src/
â”œâ”€â”€ foundation/        â†’ Business logic & domain
â”‚   â”œâ”€â”€ data/         â†’ DTOs, models
â”‚   â””â”€â”€ domain/       â†’ Entities, use cases, params
â”œâ”€â”€ infrastructure/   â†’ 3rd party wrappers
â”‚   â”œâ”€â”€ analytics/    â†’ Firebase, PostHog (wrapped)
â”‚   â”œâ”€â”€ network/      â†’ Dio (wrapped)
â”‚   â”œâ”€â”€ notification/ â†’ FCM (wrapped)
â”‚   â””â”€â”€ storage/      â†’ Hive (wrapped)
â”œâ”€â”€ application/      â†’ App-level services
â”œâ”€â”€ configuration/    â†’ DI & environment setup
â”œâ”€â”€ constants/        â†’ Global constants
â”œâ”€â”€ errors/           â†’ Exception & failure classes
â”œâ”€â”€ extensions/       â†’ Dart type extensions
â””â”€â”€ helpers/          â†’ Pure utility functions
```

**Lihat ARCHITECTURE.md untuk detail lengkap setiap folder!**

---

## ğŸ¯ Best Practices

### DO's âœ…

1. **Wrap semua third-party packages**
   ```dart
   abstract class YourService { }
   class YourServiceImpl implements YourService { }
   ```

2. **Make everything configurable**
   ```dart
   // Support custom configuration
   Future<void> initialize(YourServiceConfig config);
   ```

3. **Use dependency injection**
   ```dart
   // Constructor injection
   class MyService {
     final Dependency dependency;
     MyService(this.dependency);
   }
   ```

4. **Provide clear interfaces**
   ```dart
   // Well-documented abstract class
   abstract class NetworkService {
     /// Performs GET request to [url]
     Future<Response> get(String url);
   }
   ```

5. **Use Either for error handling**
   ```dart
   Future<Either<Failure, Success>> doSomething();
   ```

6. **Keep domain pure**
   ```dart
   // No external dependencies in entities
   class UserEntity {
     final String id;
     final String name;
   }
   ```

### DON'Ts âŒ

1. **Jangan expose third-party types**
   ```dart
   // âŒ BAD
   Future<DioResponse> get(String url);
   
   // âœ… GOOD
   Future<Response> get(String url);
   ```

2. **Jangan hardcode app-specific logic**
   ```dart
   // âŒ BAD
   if (appName == 'BUMA Absensi') { }
   
   // âœ… GOOD - use callbacks/strategies
   await onCustomEvent?.call();
   ```

3. **Jangan use static state**
   ```dart
   // âŒ BAD
   class MyService {
     static User? currentUser;
   }
   
   // âœ… GOOD
   class MyService {
     User? getCurrentUser();
   }
   ```

4. **Jangan coupling dengan UI framework**
   ```dart
   // âŒ BAD
   void showDialog(BuildContext context);
   
   // âœ… GOOD
   Stream<Event> get events; // Let consumer handle UI
   ```

5. **Jangan skip documentation**
   ```dart
   // âœ… Document public APIs
   /// Description of what this does
   Future<void> doSomething();
   ```

---

## ğŸ”„ Adding New Features

### Checklist untuk Feature Baru:

1. â˜‘ï¸ **Define interface di layer yang tepat**
   - Domain logic â†’ `foundation/domain/`
   - Infrastructure â†’ `infrastructure/{service}/contract/`
   - Application service â†’ `application/{service}/contract/`

2. â˜‘ï¸ **Create implementation**
   - Put di folder `impl/` atau `{service}.impl.dart`
   - Wrap third-party packages dengan interface

3. â˜‘ï¸ **Add to DI container**
   - Register di `configuration/di/`
   - Use factory or singleton appropriately

4. â˜‘ï¸ **Export via barrel file**
   - Add to appropriate barrel file
   - Don't expose internal implementation details

5. â˜‘ï¸ **Document thoroughly**
   - Add dartdoc comments
   - Provide usage examples
   - Document any required setup

6. â˜‘ï¸ **Make it configurable**
   - Support custom configurations
   - Provide sensible defaults
   - Allow overrides per app

7. â˜‘ï¸ **Test compatibility**
   - Test di minimal satu consumer app
   - Verify backward compatibility
   - Check for breaking changes

---

## ğŸ“ Naming Conventions

```dart
// Entities
user.entity.dart              â†’ class UserEntity

// Models (DTOs)
user_response.model.dart      â†’ class UserResponseModel

// Use Cases
get_user_profile.usecase.dart â†’ class GetUserProfileUseCase

// Services (Interfaces)
network.service.dart          â†’ abstract class NetworkService

// Service Implementations
network.service.impl.dart     â†’ class NetworkServiceImpl
// atau
impl/dio_network.service.dart â†’ class DioNetworkServiceImpl

// Extensions
string.extension.dart         â†’ extension StringExtension on String

// Helpers
date_time.helper.dart         â†’ class DateTimeHelper

// Constants
api.constant.dart             â†’ class ApiConstants
```

---

## ğŸ§ª Testing Guidelines

1. **Unit tests untuk business logic**
   - Test use cases dengan mock dependencies
   - Test entities dan value objects

2. **Integration tests untuk services**
   - Test service implementations
   - Mock third-party packages

3. **Mock-friendly design**
   - All dependencies via constructor
   - Use interfaces for all services

---

## ğŸ“š Key References

- **ARCHITECTURE.md** - Complete architecture documentation
- **README.md** - Package overview and setup
- **CHANGELOG.md** - Version history

---

## âš ï¸ Important Notes

1. **Breaking Changes**
   - Avoid at all costs
   - If necessary, deprecate first
   - Provide migration guide

2. **Versioning**
   - Follow semantic versioning
   - Update CHANGELOG.md
   - Tag releases properly

3. **Consumer Apps**
   - Test changes di multiple apps
   - Consider different use cases
   - Maintain backward compatibility

---

**Remember**: Core library harus **STABLE**, **GENERIC**, dan **FLEXIBLE**. Kode yang terlalu spesifik untuk satu app tidak boleh ada di sini!
